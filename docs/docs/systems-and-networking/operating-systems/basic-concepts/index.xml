<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Novel CS</title>
    <link>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/</link>
    <description>Recent content on Novel CS</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/clock-tick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/clock-tick/</guid>
      <description>How a timer is implemented in Operating System? # Implementing a timer under the hood in an operating system or application involves several key components and mechanisms. Here&amp;rsquo;s an overview of how timers work:
1. Timer Creation and Storage # When a timer is created, it typically specifies a duration (e.g., 5 seconds) and an action to be executed when the timer expires. The system stores this timer in a data structure, often sorted by the time when each timer is set to expire.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/coroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/coroutine/</guid>
      <description>Processes # Separate instances of programs. Independent execution units Heavyweight, more memory and overhead. Isolated memory space. Require IPC for communication. Good for high isolation, parallelism. Threads # Units of execution within a process. Preemptive multitasking — operating system’s scheduler determines when a thread should be paused and resumed Lighter weight, less overhead. Share memory space. Direct communication. Good for concurrency and shared data. Coroutines # Cooperative units within a thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/io-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/io-management/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/memory-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/memory-management/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/process/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/process/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://example.org/docs/systems-and-networking/operating-systems/basic-concepts/thread/</guid>
      <description> Thread Scheduling VS Process Scheduling # </description>
    </item>
    
  </channel>
</rss>
